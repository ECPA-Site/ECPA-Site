<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Roblox Mobile - Save System</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        #gui { position: fixed; top: 10px; left: 10px; color: white; pointer-events: none; z-index: 10; }
        .card { background: rgba(0,0,0,0.6); padding: 12px; border-radius: 12px; backdrop-filter: blur(8px); border: 1px solid rgba(255,255,255,0.1); }
        .bar { width: 160px; height: 10px; background: #222; border-radius: 5px; margin-top: 5px; overflow: hidden; border: 1px solid #444; }
        #hp-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #00ff44, #00ffcc); transition: width 0.3s; }
        
        /* –ö–Ω–æ–ø–∫–∞ –º–µ–Ω—é */
        #menu-open { position: fixed; top: 10px; right: 10px; padding: 10px 20px; background: rgba(0,0,0,0.6); color: white; border-radius: 8px; border: 1px solid white; pointer-events: auto; cursor: pointer; }

        /* –û–∫–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–π */
        #save-menu { position: fixed; inset: 0; background: rgba(0,0,0,0.85); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 100; color: white; backdrop-filter: blur(10px); }
        .slot { background: #333; margin: 8px; padding: 15px; border-radius: 10px; width: 280px; border: 1px solid #555; }
        .slot b { color: #00f2ff; display: block; margin-bottom: 5px; }
        .slot button { margin: 5px 5px 0 0; padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        .btn-save { background: #28a745; color: white; }
        .btn-load { background: #007bff; color: white; }
        #close-menu { margin-top: 20px; background: #ff4444; color: white; padding: 10px 30px; border-radius: 20px; border: none; }

        /* –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ */
        #joystick-zone { position: fixed; bottom: 40px; left: 40px; width: 110px; height: 110px; background: rgba(255,255,255,0.1); border-radius: 50%; border: 2px solid white; z-index: 20; }
        #stick { position: absolute; top: 30px; left: 30px; width: 50px; height: 50px; background: white; border-radius: 50%; opacity: 0.8; pointer-events: none; }
        #attack-btn { position: fixed; bottom: 40px; right: 40px; width: 80px; height: 80px; background: rgba(255,50,50,0.7); border-radius: 50%; border: 4px solid white; color: white; font-size: 35px; display: flex; align-items: center; justify-content: center; z-index: 20; box-shadow: 0 0 20px rgba(255,0,0,0.3); }
    </style>
</head>
<body>

<div id="gui">
    <div class="card">
        <b>‚ù§Ô∏è –ñ–ò–ó–ù–¨</b>
        <div class="bar"><div id="hp-fill"></div></div>
        <div style="margin-top:8px; font-weight: bold;">üíé –ö–†–ò–°–¢–ê–õ–õ–´: <span id="coins">0</span></div>
    </div>
</div>

<div id="menu-open" onclick="toggleMenu(true)">üíæ –ú–ï–ù–Æ</div>

<div id="save-menu">
    <h2>–°–ò–°–¢–ï–ú–ê –°–û–•–†–ê–ù–ï–ù–ò–ô (4 –°–õ–û–¢–ê)</h2>
    <div id="slots-container"></div>
    <button id="close-menu" onclick="toggleMenu(false)">–ù–ê–ó–ê–î –í –ò–ì–†–£</button>
</div>

<div id="joystick-zone"><div id="stick"></div></div>
<div id="attack-btn">‚öîÔ∏è</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
/** --- –ü–ï–†–ï–ú–ï–ù–ù–´–ï --- **/
let playerHP = 100, maxHP = 100, coins = 0;
let lastHitTime = 0, joyX = 0, joyY = 0, yaw = 0, lastTouchX = 0;
const enemies = [], particles = [];

/** --- –°–ò–°–¢–ï–ú–ê –°–û–•–†–ê–ù–ï–ù–ò–ô --- **/
function toggleMenu(show) {
    document.getElementById('save-menu').style.display = show ? 'flex' : 'none';
    if(show) updateSlotsUI();
}

function saveGame(slotId) {
    const data = {
        hp: playerHP,
        coins: coins,
        date: new Date().toLocaleString()
    };
    localStorage.setItem('roblox_slot_' + slotId, JSON.stringify(data));
    updateSlotsUI();
    alert("–ò–≥—Ä–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ —Å–ª–æ—Ç " + slotId);
}

function loadGame(slotId) {
    const data = JSON.parse(localStorage.getItem('roblox_slot_' + slotId));
    if(data) {
        playerHP = data.hp;
        coins = data.coins;
        document.getElementById('coins').innerText = coins;
        toggleMenu(false);
        alert("–ó–∞–≥—Ä—É–∂–µ–Ω–æ!");
    }
}

function updateSlotsUI() {
    const container = document.getElementById('slots-container');
    container.innerHTML = '';
    for(let i=1; i<=4; i++) {
        const data = JSON.parse(localStorage.getItem('roblox_slot_' + i));
        const div = document.createElement('div');
        div.className = 'slot';
        div.innerHTML = `
            <b>–°–õ–û–¢ ${i}</b>
            <div style="font-size: 12px; opacity: 0.8;">${data ? `üíé:${data.coins} | ‚ù§Ô∏è:${Math.round(data.hp)}%<br>${data.date}` : '–ü—É—Å—Ç–æ'}</div>
            <button class="btn-save" onclick="saveGame(${i})">Save</button>
            ${data ? `<button class="btn-load" onclick="loadGame(${i})">Load</button>` : ''}
        `;
        container.appendChild(div);
    }
}

/** --- –°–¶–ï–ù–ê --- **/
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);
scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const sun = new THREE.DirectionalLight(0xffffff, 0.8);
sun.position.set(10, 20, 10);
scene.add(sun);

const ground = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshStandardMaterial({ color: 0x3ea33e }));
ground.rotation.x = -Math.PI / 2;
scene.add(ground);

/** --- –ü–ï–†–°–û–ù–ê–ñ –ò –í–†–ê–ì–ò --- **/
const player = new THREE.Group();
const body = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.2, 0.5), new THREE.MeshStandardMaterial({color: 0x00d4ff}));
body.position.y = 0.6;
player.add(body);
scene.add(player);

function spawnEnemy() {
    const e = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.2, 0.8), new THREE.MeshStandardMaterial({color: 0xff4400}));
    e.position.set(Math.random()*40-20, 0.6, Math.random()*40-20);
    e.userData = { hp: 30 };
    enemies.push(e);
    scene.add(e);
}
for(let i=0; i<6; i++) spawnEnemy();

/** --- –ß–ê–°–¢–ò–¶–´ –†–ï–ì–ï–ù–ï–†–ê–¶–ò–ò --- **/
function spawnRegenParticle() {
    const pGeo = new THREE.PlaneGeometry(0.2, 0.2);
    const pMat = new THREE.MeshBasicMaterial({ color: 0x00ff44, transparent: true, opacity: 0.8 });
    const p = new THREE.Mesh(pGeo, pMat);
    p.position.set(player.position.x + (Math.random()-0.5), 0.5, player.position.z + (Math.random()-0.5));
    p.userData = { life: 1.0 };
    particles.push(p);
    scene.add(p);
}

/** --- –£–ü–†–ê–í–õ–ï–ù–ò–ï --- **/
const stick = document.getElementById('stick');
const joyZone = document.getElementById('joystick-zone');

window.addEventListener('touchstart', (e) => {
    for(let i=0; i<e.touches.length; i++) {
        if(e.touches[i].clientX > window.innerWidth / 2) lastTouchX = e.touches[i].clientX;
    }
}, {passive: false});

window.addEventListener('touchmove', (e) => {
    if(document.getElementById('save-menu').style.display === 'flex') return;
    e.preventDefault();
    for(let i=0; i<e.touches.length; i++) {
        const t = e.touches[i];
        if (t.clientX < window.innerWidth / 2) {
            const rect = joyZone.getBoundingClientRect();
            const dx = t.clientX - (rect.left + rect.width/2);
            const dy = t.clientY - (rect.top + rect.height/2);
            const dist = Math.min(Math.hypot(dx, dy), 40);
            const angle = Math.atan2(dy, dx);
            joyX = Math.cos(angle) * (dist / 40);
            joyY = Math.sin(angle) * (dist / 40);
            stick.style.transform = `translate(${Math.cos(angle)*dist}px, ${Math.sin(angle)*dist}px)`;
        } else {
            const deltaX = t.clientX - lastTouchX;
            yaw -= deltaX * 0.008;
            lastTouchX = t.clientX;
        }
    }
}, {passive: false});

window.addEventListener('touchend', (e) => {
    if(e.touches.length === 0) {
        joyX = 0; joyY = 0;
        stick.style.transform = `translate(0,0)`;
    }
});

document.getElementById('attack-btn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    enemies.forEach((en, i) => {
        if(player.position.distanceTo(en.position) < 4) {
            en.userData.hp -= 15;
            if(en.userData.hp <= 0) {
                scene.remove(en);
                enemies.splice(i, 1);
                coins += 5;
                document.getElementById('coins').innerText = coins;
                setTimeout(spawnEnemy, 2000);
            }
        }
    });
});

/** --- –¶–ò–ö–õ --- **/
const clock = new THREE.Clock();
function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    const now = Date.now();

    // –î–≤–∏–∂–µ–Ω–∏–µ
    if(Math.abs(joyX) > 0.1 || Math.abs(joyY) > 0.1) {
        const move = new THREE.Vector3(joyX, 0, joyY);
        move.applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
        player.position.addScaledVector(move, 8 * dt);
        player.rotation.y = yaw + Math.atan2(-joyX, -joyY);
    }

    // –†–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏—è
    if (now - lastHitTime > 3000 && playerHP < maxHP) {
        playerHP += 5 * dt;
        if(Math.random() > 0.8) spawnRegenParticle();
    }
    document.getElementById('hp-fill').style.width = Math.max(0, playerHP) + "%";

    // –ß–∞—Å—Ç–∏—Ü—ã
    for(let i=particles.length-1; i>=0; i--) {
        particles[i].position.y += dt;
        particles[i].userData.life -= dt;
        particles[i].material.opacity = particles[i].userData.life;
        if(particles[i].userData.life <= 0) {
            scene.remove(particles[i]);
            particles.splice(i, 1);
        }
    }

    // –í—Ä–∞–≥–∏
    enemies.forEach(e => {
        const d = player.position.distanceTo(e.position);
        if(d < 15) {
            e.lookAt(player.position.x, 0.6, player.position.z);
            e.position.addScaledVector(new THREE.Vector3().subVectors(player.position, e.position).normalize(), 3.5 * dt);
            if(d < 1.4) {
                playerHP -= 15 * dt;
                lastHitTime = now;
                if(playerHP <= 0) location.reload();
            }
        }
    });

    // –ö–∞–º–µ—Ä–∞
    camera.position.set(player.position.x + Math.sin(yaw)*10, player.position.y + 6, player.position.z + Math.cos(yaw)*10);
    camera.lookAt(player.position.x, player.position.y, player.position.z);

    renderer.render(scene, camera);
}
animate();

window.onresize = () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
};
</script>
</body>
</html>
